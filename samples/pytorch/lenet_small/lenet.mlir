#map = affine_map<(d0, d1, d2, d3) -> (d1)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map2 = affine_map<(d0, d1, d2, d3) -> (0, d1, d2, d3)>
module attributes {torch.debug_module_name = "lenet"} {
  ml_program.global private mutable @global_seed(dense<0> : tensor<i64>) : tensor<i64>
  func.func @forward(%arg0: tensor<1x3x32x32xf32>) -> tensor<1x6x14x14xf32> {
    %cst = arith.constant dense<[0.0930064917, 0.0625359491, -0.0745791048, -0.0485111959, -0.0629666895, -0.0812202468]> : tensor<6xf32>
    %cst_0 = arith.constant dense<"0x87CCC2BDD677CF3C25BE033C5F8E5DBCB097BCBD5E68D7BD2005C73D49B902BDC597D23DFBE5A23C3514793DC1A1933CC1B0B13DC4ABE43C3F61053CE644B4BD03E1B0BD95CCA8BDAF361D3DC908E9BD68717EBCCFBCB83C40DBC9BDC3AB333D23B281BD5E18EC3D1111803B6CEB93BD256EB3BD9D72983D25F00DBD76BA043DE36F213C44875E3C8A85CA3D9EBEE4BD7E9CBA3DB5A43CBDB4CAD33DA3432A3BD4E5933D949B76BCFACF153D42A1C9BDCE52A53CA98FEABA91E2A43D9D235EBA27B5543D68FC783D7C592B3D734F913D8D33133DF2453EBDBA904CBD56F0C53DD8E2653DBA883FBDFCC87B3DE1D7D9BD8788433DAC0852BDFC2822BD5E84C93DA583303CC079E3BD269F9ABD33B8973CA760B0BDDF52AE3D013BADBD311E263D9A72993D1F44C9BD6D21B53CEBF1043D74A7DE3D4C8482BC75F911BD4EBF79BA9F78A53D7968B3BDCC789D3DDE7F613CABB91DBDFF97D9BCD7F739BA82CB1D3D4F65DE3D0FC8D2BDA510903C2345743D4FDBE93D04AEB3BCD07B953B781F32BC7E72003D97FA2C3D459A84BD16AA253D076EB23D107D59BC826F2CBC39E6BCBC79FC11BDA48FABBD4F48A9BDDF563B3B79DAE4BD5F92A5BD5BA57DBDD722443DE0C5ADBB38BA9DBD3D9DA03D3290EEBC917ECDBDC3A2C5BD05AC82BC705B74BD2C7CC83D9ED3503D5F1E463D03C128BD8ED3C8BD684EDA3D68998DBDE58D213D1366C8BDE50E8CBDF5845E3DC81483BDF29EB83DD7DF0B3D0B87C43D8FC2413D53C9733D250EC2BD895882BBF025A5BD4DC3113D63DFAEBD17F2C23D595E593C850C0F3DCA484CBD3FD353BDE29AEA3D26AF133DD65BEABDDD3AB23DD5DE1E3D4F2EBCBD7A3E723D682F09BD99590E3CB8BC2BBD4D5ADABC0D0E31BD8CA7EFBC8440E6BCBB09B3BD0F06ABBC45CB43BDB4DFBBBDFA1A1A3D7193603D38D4A5BD45B8A7BCD5E7D33B11149F3DC32833BC6D86373DC7CCC1BD6D358EBD4D08E7BD25E1BB3C25C2A93DDD4874BD2F2887BDAEFFB1BDCFB0E73D63AA173DD61E9D3B6E3F713D132D39BCB8930A3D015D9B3D7467D13D468913BCE64BE4BD94BB343D7BDFA43C7B1E0DBC2727C93DD1B292BCF6DFC5BC3E3BA7BD60AFC6BC12B49C3DC8797D3DCE778F3D8A2F9C3DACD85EBA7752FD3C60CFEBBDB70A5FBDA288B0BD0083DBBB50CB8CBC717A393D64F4E1BD436387BC1F0543BD12DDA63D8398BABD1D3AAEBD14AA723D37FF85BD0ADB683DBFCFE23DC71A94BDEB68A7BDBD09A93DAFD7E53D6789AC3CEE62863D17C0CFBD5275003DB07988BDF91186BD26B0C83DC454903D74E3E13DA42E85BD6333DBBDC68D913DB3E8B9BD3B2E98BD91E6A13D387D2C3DBCF6143C0F171DBD059CAD3D2E3C823D6542513DDE66E93D6286373D032DAF3DB9F07A3DAF8EA2BD5B1391BC9A132E3DF413B4BD079C1B3D6B11D33DC5479C3DE5B35EBC9E2C1A3DBDC3DFBDB0DAEA3D5150D93D6537663C28FCE83D40CE31BD7D46B63C7FFEEFBBF3317BBD4D41653DA80F1C3D49D2D43D8B9DA53C2EFAC3BC9E8794BD6C6B7CBD448435BDEC91D23DAC3A8EBDAF04D73D8B2D373CBF3F933D234C9BBD8BB00FBCD066CF3D98B33A3C7366D9BD9C1182BDB669A8BD83BC89BDAF6E633D5CA155BD8D9D593DEBEF653D1E89D3BC3CE332BD4AD246BD0C6817BD05F5AC3C9037AC3D424ED2BB060269BD76B1A5BCD994B6BDCDF6023D3C4B9D3CD8F5D33DEB3B01BDE35CC53D675EE83D582597BD1885A53DCCF63A3D126B9FBC4F5546BDFDF1B93D5A53BA3CF185DDBC4163593DC4AEB53DE07AB63D5F323F3B4271BC3DE04980BB6A6BE6BCEAD63FBCD66438BDAAF7DABDD34FCB3D114194BD21FA983CE57787BD7C9042BD6B68D5BDF3E810BC6D53D43DF1EC883D9BE07EBD7ED55F3CC225943D28C824BC4F4DBBBD0FA6AFBCA35DB7BCCF0CB7BC8F73783D236DA9BD56739ABD434D6BBD2EB846BDA17A1FBCE63205BD25754C3D7A7673BD217E363D97CFA83CC93FD0BDB87CC33A452E623D30F631BC9EDE723A4EF8A4BD9997B8BDE86E1CBD6EF70FBD91B69F3D1E9ACA3C60A3CCBBC8E7BE3D3F98AABC5703E4BDAC6A4ABDFB1D2EBD6975E13DC953833DE221A0BD9EB199BD7A59603C8E95C0BB9D47A93D3E7F3ABD4E79C4BDE7909ABC65C5BE3CC624DC38CE1440BCAC4F2ABDAD6BBD3CFED700BD91549EBDBA35C9BD4CC2693D209D48BDCF67A1BD7678BE3DEDA06E3D27E8B93D5CDF5D3D21B3A83D3692C93C358688BD5D0944BC1E5E583CAD7394BC1D3A3C3BB84110BD851E3BBA47E47B3D2087BF3D68D6DE3D1FE0C23DAE03C3BCA9E8D63D78623DBDEF55B3BD3324983DD2C6763B76BFD33D4781933CF9B8A33BF4E958BC2A15CEBD4EC975BD2DB0833B88BDB6BDF491C5BD973089BC9BA2D83DB94C1DBDE158353DA3C1E5BD79315E3CB925CDBD702EB73DFDAE633DB012853D884FC93D3FFC83BDC2A58E3DF2719EBD7B81BF3D92BA753D66113BBD0FBEF13C1D92FE3CB858ECBDFFFE93BDD09555BDFDAA273DAD8433BD8312ECBC"> : tensor<6x3x5x5xf32>
    %cst_1 = arith.constant 0.000000e+00 : f32
    %cst_2 = arith.constant 0xFF800000 : f32
    %0 = tensor.empty() : tensor<1x6x28x28xf32>
    %1 = linalg.generic {indexing_maps = [#map, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%cst : tensor<6xf32>) outs(%0 : tensor<1x6x28x28xf32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<1x6x28x28xf32>
    %2 = linalg.conv_2d_nchw_fchw {dilations = dense<1> : vector<2xi64>, strides = dense<1> : vector<2xi64>} ins(%arg0, %cst_0 : tensor<1x3x32x32xf32>, tensor<6x3x5x5xf32>) outs(%1 : tensor<1x6x28x28xf32>) -> tensor<1x6x28x28xf32>
    %3 = linalg.generic {indexing_maps = [#map2, #map1], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%2 : tensor<1x6x28x28xf32>) outs(%0 : tensor<1x6x28x28xf32>) {
    ^bb0(%in: f32, %out: f32):
      %8 = arith.cmpf ugt, %in, %cst_1 : f32
      %9 = arith.select %8, %in, %cst_1 : f32
      linalg.yield %9 : f32
    } -> tensor<1x6x28x28xf32>
    %4 = tensor.empty() : tensor<1x6x14x14xf32>
    %5 = linalg.fill ins(%cst_2 : f32) outs(%4 : tensor<1x6x14x14xf32>) -> tensor<1x6x14x14xf32>
    %6 = tensor.empty() : tensor<2x2xf32>
    %7 = linalg.pooling_nchw_max {dilations = dense<1> : vector<2xi64>, strides = dense<2> : vector<2xi64>} ins(%3, %6 : tensor<1x6x28x28xf32>, tensor<2x2xf32>) outs(%5 : tensor<1x6x14x14xf32>) -> tensor<1x6x14x14xf32>
    return %7 : tensor<1x6x14x14xf32>
  }
}

